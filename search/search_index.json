{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Coal","text":"<p>This is the official documentation for the Coal programming language. </p>"},{"location":"#about","title":"About","text":"<p>Coal is a declarative, statically typed, purely functional programming language with simple and intuitive syntax. It provides algebraic data types and pattern matching, extensible records, structural recursion, codata, corecursion, and traits (type classes), among other features. </p> <p>Coal\u2019s type system, like Haskell\u2019s and ML\u2019s, supports type inference and parametric polymorphism, drawing on the System-F lambda calculus. The Coal compiler is implemented in Haskell and targets LLVM for code generation. The language is based on ideas where streams and other infinite data types are described as coalgebras \u2014 hence the name Coal.</p> <p>This project is licensed under the terms of the MIT license. The source code is hosted at codeberg.org/laserpants/coal.</p>"},{"location":"#rethinking-recursion","title":"Rethinking recursion","text":"<p>As a total language, Coal takes a different approach to recursion, following the motto that \"recursion is the <code>goto</code> of functional programming.\" To guarantee that programs are provably terminating, recursion is only available in a restricted form, known as structural recursion. Under this regime, each recursive call operates on a strictly smaller part of some finite data structure, progressing toward a base case. </p> <pre><code>  fun sum(numbers : List&lt;int32&gt;) : int32 =\n    fold(numbers) {\n      | [] =&gt; 0 \n      | x :: @tot =&gt; x + tot\n    }\n</code></pre> <p>The special <code>@</code>-pattern variable used here makes <code>tot</code> recieve the result from calling the fold again using the sub-list matched by the pattern. </p> <p>A distinction is made between ordinary, finite data, which is produced and consumed in this way, and potentially infinite data \u2014 the kind that may result from processes that run indefinitely. The latter is known as codata. The codata equivalent of lists, for example, are streams.</p> <pre><code>  cotype Stream&lt;a&gt; = { Head : a, Tail : Stream&lt;a&gt; }\n\n  unfold enum_from(n : int32) : Stream&lt;int32&gt; {\n    , Head = n\n    , @Tail = n + 1\n  }\n\n  let nats = enum_from(0)\n</code></pre> <p>In this example, the <code>@</code> in the field name causes the expression on the right (<code>n + 1</code>) to become the next seed value, which is fed back into <code>enum_from</code> to generate the rest of the stream.</p> <p>These code samples illustrate two distinct modes of recursive control flow. If you are familiar with recursion schemes in a language like Haskell, recursion in Coal is based on the same principles. In that framework, <code>fold</code> and <code>unfold</code> are called catamorphisms and anamorphisms, respectively. </p>"},{"location":"data-and-codata/","title":"Data and codata","text":"<p>Data and codata are really \"two sides of the same coin.\" This correspondence can be traced back to category theory, where precise formal meaning is given to these concepts. </p>"},{"location":"data-and-codata/#duality","title":"Duality","text":"<p>Reversing the arrows is a recurring theme in category theory. Products and sum types describe ways of combining values: a product collects multiple values into one, while a sum, or disjoint union, represents a choice between alternatives. A disjoint union is sometimes also referred to as a coproduct. The reason is that a product is defined by a universal property that allows you to extract its components, whereas a coproduct is defined dually: it allows you to inject a value from one of the alternatives and to handle each case uniquely. </p> <p> </p> <p>In other words, a disjoint union is the categorical dual of a product.</p>"},{"location":"data-and-codata/#initial-algebras","title":"Initial algebras","text":"<p>An algebraic data type can be understood as the initial algebra of a functor. Intuitively, this means that it provides the smallest, well-founded solution to a type equation \u2014 one that can be consumed by a fold (a catamorphism). </p> <p> </p>"},{"location":"data-and-codata/#pattern-functors-and-fixed-points","title":"Pattern functors and fixed points","text":"<p>Data types are built from constructors. Consider the <code>List</code> type, for example:</p> <pre><code>type List&lt;t&gt; \n  = Nil\n  | Cons(t, List&lt;t&gt;)\n</code></pre> <p>The pattern functor for a data type abstracts recursion by isolating one layer of the data structure, leaving the recursive portion as a parameter. For <code>List</code>, the corresponding pattern functor is:</p> <pre><code>type ListF&lt;t, a&gt; \n  = NilF\n  | ConsF(t, a)\n</code></pre> <p>Notice that, unlike <code>List</code>, the type <code>ListF</code> is not recursive. In mathematical terms, this functor can be expressed by the equation:</p> \\[ F(X) = \\mathsf{1} + (t \\times X) \\] <p>where</p> <ul> <li>\\(\\mathsf{1}\\) corresponds to <code>NilF</code>,</li> <li>\\((t \u00d7 X)\\) corresponds to <code>ConsF(t, a)</code>.</li> </ul> <p>The actual recursive type is the fixed point of \\(F\\):</p> \\[ \\texttt{List&lt;t&gt;} \\cong \\mu F \\cong F(\\mu F) \\]"},{"location":"data-and-codata/#algebras-and-folds","title":"Algebras and folds","text":"<p>An algebra for a functor \\(F\\) is a type \\(A\\) (the carrier) together with an arrow \\(F(A) \\rightarrow A\\). This function (or morphism to be more accurate) is called the structure map and it is precisely what the pattern matching clauses (along with the <code>@</code>-pattern syntax) in <code>fold</code> expressions describe:</p> <pre><code>fold(xs) {\n  Nil           =&gt; 0\n  Cons(x, @acc) =&gt; x + acc\n}\n</code></pre> <p>The initial algebra \\((\\mu F, \\text{in})\\) is defined by the canonical map \\(\\text{in} : F(\\mu F) \\rightarrow \\mu F\\). The carrier of this algebra is the data type itself (i.e., <code>List&lt;t&gt;</code> in this example). The fact that this is an initial object means that, for evey other algebra \\(A\\), there is a unique function \\(h : \\mu F \\rightarrow A\\) that makes the diagram commute. That unique morphism is precisely what the <code>fold</code> operator computes.</p> <p>In the other direction, a codata type corresponds to the final coalgebra of a functor: it is the largest (potentially infinite) solution that can be observed or generated by an unfold (anamorphism). In this description, algebras and coalgebras are each others\u2019 duals. By simply reversing the direction of the arrows in their diagrams, an algebra turns into a coalgebra and vice versa.</p> <p> </p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation-and-setup","title":"Installation and setup","text":"<p>The compiler has been tested on Linux and Mac OS.</p> <p>Important notice</p> <p>The Coal compiler is still a work in progress.  There are many important features missing. See the roadmap to keep track of current progress. Also consider contributing to the project.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":""},{"location":"getting-started/#haskellghc","title":"Haskell/GHC","text":"<p>A recent version of GHC is needed. It is recommended to install Haskell, GHC and Stack using the GHCup tool.</p>"},{"location":"getting-started/#llvm","title":"LLVM","text":"<p>An LLVM toolchain that provides <code>llc</code> (the LLVM static compiler) is also required.</p>"},{"location":"getting-started/#linux","title":"Linux","text":"<ul> <li>Debian/Ubuntu (or derivatives):</li> </ul> <pre><code>sudo apt update\nsudo apt install llvm clang     \n</code></pre> <ul> <li>Fedora, RHEL, or CentOS:</li> </ul> <pre><code>sudo dnf install llvm clang\n</code></pre> <ul> <li>Arch Linux:</li> </ul> <pre><code>sudo pacman -S llvm\n</code></pre>"},{"location":"getting-started/#mac-os","title":"Mac OS","text":"<p>See Getting Started with the LLVM System, or install using Homebrew:</p> <pre><code>brew install llvm\n</code></pre> <p>Note: If you use Homebrew to install LLVM, you may need to add the binaries to your <code>PATH</code> manually. </p>"},{"location":"getting-started/#additional-dependencies","title":"Additional dependencies","text":"<ul> <li>GCC (probably not needed on Mac)</li> <li>Boehm\u2013Demers\u2013Weiser garbage collector</li> <li>The GNU Multiple Precision Arithmetic Library</li> </ul>"},{"location":"getting-started/#linux_1","title":"Linux","text":"<ul> <li>Debian/Ubuntu (or derivatives):</li> </ul> <pre><code>sudo apt update\nsudo apt install libgc-dev libgmp-dev build-essential\n</code></pre> <ul> <li>Fedora, RHEL, or CentOS:</li> </ul> <pre><code>sudo dnf install gc-devel gmp-devel gcc make\n</code></pre> <ul> <li>Arch Linux:</li> </ul> <pre><code>sudo pacman -S gc gmp base-devel\n</code></pre>"},{"location":"getting-started/#mac-os_1","title":"Mac OS","text":"<pre><code>brew install bdw-gc gmp\n</code></pre>"},{"location":"getting-started/#building-the-compiler","title":"Building the compiler","text":"<p>Clone the repository:</p> <pre><code>git clone ssh://git@codeberg.org/laserpants/coal.git\n</code></pre> <pre><code>cd coal &amp;&amp; stack install\n</code></pre> <p>Restart or refresh your shell, using e.g., <code>exec $SHELL -l</code>. To verify that the executable is installed, run:</p> <pre><code>coal --help\n</code></pre>"},{"location":"getting-started/#hello-world","title":"Hello, world!","text":"<pre><code>module Main {\n\n  fun main() = trace_string(\"Hello, world!\")\n\n}\n</code></pre> <p>Save this program as \"Main.coal\". Compile the program with the command:</p> <pre><code>coal Main.coal -o dist\n</code></pre>"},{"location":"language-manual/","title":"Language manual","text":""},{"location":"language-manual/#modules","title":"Modules","text":"<p>Projects in Coal are organized as collections of modules. Modules provide a way to group related functionality into distinct namespaces. A module can contain functions, type definitions, traits, and other language constructs, typically focused on a specific purpose within a library or application.</p> <pre><code>module &lt;path&gt;(&lt;export_list&gt;) {\n  &lt;definition&gt;\n  &lt;definition&gt;\n  ...\n}\n</code></pre> <p>Every module is uniquely identified by its path. </p> <ul> <li>A module\u2019s path mirrors the directory structure of the source file in which it is defined. </li> <li>Path segments begin with an uppercase letter and are separated by a dot (<code>.</code>). </li> <li>Files have a <code>.coal</code> extension. </li> </ul> <p>A module <code>Utils.Math.Trigonometry</code>, for instance, is defined in a file named <code>Trigonometry.coal</code>, located under <code>Utils/Math/</code> relative to your project\u2019s root directory:</p> <pre><code>src\n\u2514\u2500\u2500 Utils\n \u00a0\u00a0 \u2514\u2500\u2500 Math\n \u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 Trigonometry.coal\n</code></pre>"},{"location":"language-manual/#imports","title":"Imports","text":"<p>An <code>import</code> statement is used to bring in functions and other definitions from other modules. These must appear at the beginning of a module, preceding any other code.</p> <pre><code>import List(concat, head, tail)\n</code></pre> <p>The special <code>namespace</code> keyword allows you to import and access all functions, types, and other definitions from a module via their qualified names. A qualified name is formed by prefixing the name with the path of the module:</p> <pre><code>// Import the List module under its namespace\nimport namespace List\n\n  // And use it like this:\n  let zs = List.concat(xs, ys)\n</code></pre>"},{"location":"language-manual/#exports","title":"Exports","text":"<p>In a module declaration, the path identifier is followed by an optional list of exported names enclosed in parentheses. Only exported names are visible outside the module (or public in OOP terminology).</p> <pre><code>module Utils.Math.Trigonometry(sin, cos, tan) {\n  // ...\n</code></pre> <p>If this list is left out, everything in the module is exported.</p>"},{"location":"language-manual/#top-level-definitions","title":"Top-level definitions","text":"<p>Definitions that occupy the outermost scope of a module are functions, top-level let-expressions, data and codata type definitions, traits, trait instances, folds, and unfolds.</p>"},{"location":"language-manual/#functions","title":"Functions","text":"<p>A function is defined with the <code>fun</code> keyword, followed by the function\u2019s name and a list of comma-separated arguments enclosed in parentheses. The function body is simply an expression, which comes after the arguments and is preceded by an equals sign:</p> <pre><code>  fun &lt;name&gt;(&lt;arg_1&gt;, &lt;arg_2&gt;, ..., &lt;arg_n&gt;) =\n    &lt;expr&gt;\n</code></pre> <p>A type annotion can be given to indicate a function\u2019s return type, as in the following example:</p> <pre><code>  fun is_even(n : int32) : bool =\n    n % 2 == 0\n</code></pre> <p>Function parameters are patterns, allowing functions to directly deconstruct their arguments. In addition to basic variables, records, tuples, and other data constructors, patterns can also include wildcards, literals, and nested structures. </p> <pre><code>  fun grok({ n : int32 }, (fst, snd), _) =\n    ...\n</code></pre> <p>Top-level functions can also be defined in the form of a list of pattern\u2013expression pairs, separated by a <code>|</code>-symbol. For example:</p> <pre><code>  fun unpack\n    | ([a], true)    = a\n    | ([a, _], true) = a\n    | ([a, _, _], _) = a\n    | (_, _)         = 0\n</code></pre> <p>This style of top-level function is equivalent to defining the function with an explicit <code>match</code> expression inside its body: </p> <pre><code>  fun unpack(a1, a2) =\n    match(a1, a2) {\n      | ([a], true)    = a\n      | ([a, _], true) = a\n      | ([a, _, _], _) = a\n      | (_, _)         = 0\n    }\n</code></pre> <p>See Pattern matching for a more detailed discussion of patterns and the <code>match</code> syntax.</p>"},{"location":"language-manual/#main","title":"Main","text":"<p>Just like in many other programming languages, the <code>main</code> function serves as the entry point of a program:</p> <pre><code>module Main {\n\n  fun main() =\n    ...\n</code></pre>"},{"location":"language-manual/#let-expressions","title":"Let-expressions","text":"<p>The <code>let</code> keyword introduces a new name bound to the result of an expression. Inside functions, a <code>let</code> is often used to give names to intermediate values:</p> <pre><code>  fun hypotenuse(a, b) =\n    let sqr_a = a * a;\n        sqr_b = b * b\n    in \n      sqrt(sqr_a + sqr_b)\n</code></pre> <p>Here, <code>sqr_a</code> and <code>sqr_b</code> are local bindings, only visible in the body that follows the <code>in</code>.</p> <p>At the top level of a module, a <code>let</code> works in the same way, except there is no enclosing body \u2014 the binding simply introduces a global name that can be referenced elsewhere in the module (or from other modules):</p> <pre><code>  let days = \n    [ \"Monday\"\n    , \"Tuesday\"\n    , \"Wednesday\"\n    , \"Thursday\"\n    , \"Friday\"\n    , \"Saturday\"\n    , \"Sunday\" \n    ]\n</code></pre> <p>Type annotations for let-bindings look similar to those for functions:</p> <pre><code>  let days : List&lt;string&gt; =\n    [ \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\" ]\n</code></pre> <p>Since a <code>let</code> can hold any expression, top-level functions can also be defined this way:</p> <pre><code>  let add = fn(x, y) =&gt; x + y\n  // Equivalent to:\n  // fun add(x, y) = x + y\n</code></pre>"},{"location":"language-manual/#data-types","title":"Data types","text":"<p>User-defined data types in Coal are introduced using the <code>type</code> keyword. They are of the product-sum variety.</p> <p>A product type combines multiple fields into one single value: All of the components appear together in the constructed data. An RGB color triplet that contains individual red, green, and blue values can be described with a type:</p> <pre><code>type Color = Rgb(int8, int8, int8)\n</code></pre> <p>A sum type is a choice between alternatives: A value belongs to exactly one of the specified variants. A type that represents a shape that can be either a <code>Circle</code> or a <code>Rectangle</code> can be defined as:</p> <pre><code>type Shape = Circle | Rectangle\n</code></pre> <p>More complex types can be built by combining product and sum constructors. The following is a type that defines a binary tree, parameterized by the type (<code>a</code>) of its nodes:</p> <pre><code>type Tree&lt;a&gt; \n  = Leaf\n  | Node(a, Tree&lt;a&gt;, Tree&lt;a&gt;)\n</code></pre> <p>This definition says that a <code>Tree&lt;a&gt;</code> is either:</p> <ul> <li>a <code>Leaf</code> (the empty tree), or</li> <li>a <code>Node</code> containing a value of type <code>a</code> along with two sub-trees (the left and right branches).</li> </ul> <p>Using this type, we can represent any finite binary tree. For example, here is a tree of integers:</p> <pre><code>//          (4)\n//          / \\\n//       ---------\n//       /       \\\n//     (2)       (6)\n//    -----     -----\n//    /   \\     /   \\ \n//  (1)   (3) (5)   (7)  \n\nlet tree_of_gondor = \n  Node \n    ( 4\n    , Node\n        ( 2\n        , Node(1, Leaf, Leaf)\n        , Node(3, Leaf, Leaf)\n        )\n    , Node\n        ( 6\n        , Node(5, Leaf, Leaf)\n        , Node(7, Leaf, Leaf)\n        )\n    )\n</code></pre> <p>The structure of the tree is entirely determined by its constructors (<code>Leaf</code> and <code>Node</code>), which makes recursion natural. </p> <p>Algebraic data types are especially useful for describing language grammars and other hierarchical structures. Consider this JSON representation:</p> <pre><code>  type JsonValue\n    = Null\n    | Bool(bool)\n    | Number(double)\n    | String(string)\n    | Array(List&lt;JsonValue&gt;)\n    | Object(List&lt;(string, JsonValue)&gt;)\n</code></pre>"},{"location":"language-manual/#expression-syntax","title":"Expression syntax","text":"<p>Expressions are the core building blocks of programs. They include variables, literals, let-bindings, operators, and control structures like <code>if-then-else</code>. An expression can often be composed of other, smaller expressions. For example, a binary operator consists of two sub-expressions: its left-hand side and right-hand side operands:</p> <pre><code>  (+)     \n  / \\     x and y are sub-expressions of the expression x + y\n x   y\n</code></pre>"},{"location":"language-manual/#variables","title":"Variables","text":"<p>A variable in Coal is simply a name bound to a value. Unlike in imperative languages, it is not very meaningful to think of a variable as a \u201cbox\u201d that represents some data store in memory. In functional programming, expressions behave more like mathematical expressions: once a variable is defined, its value never changes.</p>"},{"location":"language-manual/#naming-rules","title":"Naming rules","text":"<p>Variable names are subject to the following rules:</p> <ul> <li>A name can consist of letters (<code>A-Z</code>, <code>a-z</code>), digits (<code>0-9</code>), and the underscore character (<code>_</code>).</li> <li>The first character of a variable name must be a lowercase letter or an underscore.</li> <li>Variable names are case-sensitive, meaning that <code>my_VAR</code> and <code>my_var</code> refer to different variables.</li> <li>Variable names cannot contain spaces.</li> <li>Special characters other than underscores (e.g., <code>!</code>, <code>#</code>, <code>%</code>, <code>@</code>) are not permitted in variable names.</li> </ul>"},{"location":"language-manual/#reserved-keywords","title":"Reserved keywords","text":"<p>Reserved language keywords cannot be used as variable names. They are:</p> <pre><code>alias           float           int64           true\nas              fn              let             type\nbignum          fold            match           unfold\nbool            fun             module          unit\nchar            if              nat             when\ncotype          import          or              where\ndouble          in              string          with\nelse            instance        then\nfalse           int32           trait\n</code></pre>"},{"location":"language-manual/#shadowing-considered-harmful","title":"Shadowing considered harmful","text":"<p>Shadowing occurs when a variable declared in an inner scope has the same name as a variable from an outer scope. </p> <pre><code>fun go(x) =\n  let x = 3 in x + 3\n</code></pre> <p>In this example, the inner <code>let</code> attempts to declare a new variable that has the same name as the function parameter, namely <code>x</code>.</p> <p>Because shadowing is often a source of subtle bugs, the Coal compiler treats it as an error.</p>"},{"location":"language-manual/#literal-expressions","title":"Literal expressions","text":"<p>A literal is an expression that directly represents a fixed value of one of the built-in primitive types, such as integers, booleans, or strings.</p>"},{"location":"language-manual/#integral-types","title":"Integral types","text":"<p>Integer literals introduced in code without an explicit type annotation, such as</p> <pre><code>let answer = 42\n</code></pre> <p>are polymorphic. The inferred type of this expression is <code>n with Numeric(n)</code>, which means that <code>n</code> can be any type, as long as it implements the <code>Numeric</code> trait (see Traits). This includes the built-in <code>int32</code>, <code>int64</code>, <code>bignum</code>, and <code>nat</code> types. All <code>Numeric</code> types support the basic arithmetic operations of addition, subtraction, and multiplication.</p> <pre><code>fun sum_of(x, y, z) = \n  x + y + z \n\nlet n : int32 = sum(1, 2, 3)\nlet d : double = sum(0.5, 1.0, 1.5)\n</code></pre>"},{"location":"language-manual/#function-application","title":"Function application","text":"<p>Unlike Haskell, ML, and OCaml, Coal uses parentheses and commas to separate arguments in function applications \u2014 a syntax more similar to languages like C, Java, or Python. For example:</p> <pre><code>concat(\"one\", \"two\")\n</code></pre> <p>This applies the function <code>concat</code> to the arguments <code>\"one\"</code> and <code>\"two\"</code>.</p> <p>By default, functions are curried. There is a difference between a function that takes multiple arguments, and one that takes a single tuple as its argument. Consider the following two type signatures:</p> <pre><code>f : a -&gt; b -&gt; c\ng : (a, b) -&gt; c\n</code></pre> <p>The first of these is in curried form, which is usually more convenient to work with. Curried functions can be partially applied. This is useful, for example, when working with higher-order functions. Suppose we define an addition function:</p> <pre><code>fun add(x, y) = x + y\n</code></pre> <p>Using partial application, we can create a new function <code>increment</code> by supplying just one argument to <code>add</code>:</p> <pre><code>let increment = add(1)\n</code></pre> <p>Partially applied functions can also be passed directly to a higher-order function like <code>map</code>:</p> <pre><code>map(add(1), [1, 2, 3, 4])   // which yields the same result as map(increment, [1, 2, 3, 4])\n</code></pre>"},{"location":"language-manual/#if-then-else","title":"If-then-else","text":"<p>If-expressions in Coal are similar to those found in many programming languages, especially other functional languages. Both the <code>then</code> and <code>else</code> clauses must be present, and they must produce values of the same type:</p> <pre><code>  if (&lt;e_1 : bool&gt;) then &lt;e_2 : t&gt; else &lt;e_3 : t&gt;\n</code></pre> <p>For example:</p> <pre><code>  if (temperature &gt; 20) then wear(\"shorts\") else go_home()\n</code></pre>"},{"location":"language-manual/#let-bindings","title":"Let-bindings","text":"<p>A let-binding introduces a new scope by matching a pattern against the result of an expression. The variables bound by the pattern become available within the expression following the <code>in</code> keyword:</p> <pre><code>let &lt;pattern&gt; = &lt;e_1&gt; in &lt;e_2&gt;\n</code></pre> <p>Variables form the simplest form of pattern, namely one that matches any value and binds it to a name:</p> <pre><code>let name = \"Zlatan\" \n</code></pre> <p>The pattern used on the left-hand side must be such that it is guaranteed to match the result of the expression <code>&lt;e_1&gt;</code>. For example:</p> <pre><code>-- Destructuring with a tuple\nlet (x, y) = (1, 2) in x + y\n\n-- Matching nested records\nlet { tidbits = { f = a | _ } } = compute(4)\n</code></pre> <p>A note about let-generalization</p> <p>In some sense, a let-binding is interchangeable with a lambda function. For example, writing <code>let x = 1 in increment(x)</code> yields the same result as <code>(fn(x) =&gt; increment(x))(1)</code>. But besides being more readable, the let-binding also serves another purpose; in Hindley-Milner languages, it is let-bindings that introduce polymorphism. Consider the following expression, which doesn\u2019t type check:</p> <pre><code>  (fn(f) =&gt; (f(3 : int32), f(\"three\")))(fn(x) =&gt; x)\n</code></pre> <p>In this example, the type of <code>f</code> is monomorphic. The type inference algorithm will try to determine its type but fail to unify <code>int32 -&gt; int32</code> with <code>string -&gt; string</code>. If we instead bind the anonymous function to a new identifier, then its type is generalized and obtains the quantified type <code>\u2200a : a -&gt; a</code> (known as a type scheme). We can now apply this function to both elements of the tuple, even though they have different types:</p> <pre><code>  let id = fn(x) =&gt; x \n    in \n      (id(3 : int32), id(\"three\"))\n</code></pre>"},{"location":"language-manual/#name-binding-semantics","title":"Name binding semantics","text":"<p>A subtle but important detail that makes let-bindings in Coal different from those in most other languages is that the identifier introduced by a <code>let</code> is not in scope within the definition itself. In other words, <code>let x = e1 in e2</code> makes <code>x</code> available in <code>e2</code>, but not in <code>e1</code>. In the ML-family of languages (e.g. OCaml), this is also the case for the standard <code>let</code> keyword. However, in these languages, a special <code>let rec</code> syntax makes it possible to evade this restriction. Coal doesn\u2019t have an equivalent to <code>let rec</code>. This prevents non-well-founded expressions, such as <code>let f = f in f</code>, but more generally, makes it impossible for any function to refer to itself.  The restriction also applies to top-level definitions. For example, as far as the compiler is concerned, the function</p> <pre><code>fun fib(n) = if (n == 0 || n == 1) then n else fib(n - 1) + fib(n - 2)\n</code></pre> <p>translates into:</p> <pre><code>let fib = fn(n) =&gt; if (n == 0 || n == 1) then n else fib(n - 1) + fib(n - 2)\n                                                     ^^^\nError: Name \"fib\" not in scope\n</code></pre> <p>In fact, one can think of a module as one big let-binding, only laid out in a more readable way:</p> <pre><code>  let\n    some_function = fn(...) =&gt; ...\n      in\n        let\n          some_other_function = fn(...) =&gt; ...\n            in\n              let \n                main = fn() =&gt; \n                  ...\n</code></pre> <p>This is why functions such as the fibonacci function above are straight out rejected by the compiler. </p>"},{"location":"language-manual/#lambda-expressions","title":"Lambda expressions","text":"<p>An anonymous (lambda) function is declared with the <code>fn</code> keyword and the \u201cfat\u201d arrow (<code>=&gt;</code>) symbol:</p> <pre><code>  fn(&lt;arg_1&gt;, &lt;arg_2&gt;, ..., &lt;arg_n&gt;) =&gt; &lt;expr&gt;\n</code></pre> <p>Function expressions are first-class objects; they can be passed as arguments to other functions, assigned and stored inside data structures, etc.</p> <pre><code>  fun apply_fst(xs, x : int32) =\n     match(xs) {\n       | f :: _ =&gt; f(x)\n       | [] =&gt; 0\n     }\n\n  fun main() =\n    let fns = \n      [ fn(x) =&gt; x + 1\n      , fn(x) =&gt; x + 2\n      , fn(x) =&gt; x + 3\n      ]\n    in\n      trace_int32(apply_fst(fns, 3))\n</code></pre> <p>Just like with let-bindings, the arguments in a lambda-function are patterns:</p> <pre><code>  fn((lhs, rhs)) =&gt; lhs\n</code></pre>"},{"location":"language-manual/#operators","title":"Operators","text":""},{"location":"language-manual/#arithmetic-and-comparison","title":"Arithmetic and comparison","text":"Description Type <code>+</code> Addition <code>\u2200n : n -&gt; n -&gt; n with Numeric(n)</code> <code>-</code> Subtraction <code>\u2200n : n -&gt; n -&gt; n with Numeric(n)</code> <code>*</code> Multiplication <code>\u2200n : n -&gt; n -&gt; n with Numeric(n)</code> <code>/</code> Division <code>\u2200q : q -&gt; q -&gt; q with Divisible(q)</code> <code>^</code> Exponentiation <code>\u2200n : n -&gt; nat -&gt; n with Numeric(n)</code> Description Type <code>==</code> Equality <code>\u2200n : n -&gt; n -&gt; bool with Comparable(n)</code> <code>!=</code> Inequality <code>\u2200n : n -&gt; n -&gt; bool with Comparable(n)</code> <code>&lt;</code> Less than <code>\u2200n : n -&gt; n -&gt; bool with Ordered(n)</code> <code>&gt;</code> Greater than <code>\u2200n : n -&gt; n -&gt; bool with Ordered(n)</code> <code>&lt;=</code> Less than or equal <code>\u2200n : n -&gt; n -&gt; bool with Ordered(n)</code> <code>&gt;=</code> Greater than or equal <code>\u2200n : n -&gt; n -&gt; bool with Ordered(n)</code> Description Type <code>%</code> Modulus <code>\u2200m : m -&gt; m -&gt; m with Modulo(m)</code>"},{"location":"language-manual/#logical","title":"Logical","text":"Description Arity Type <code>&amp;&amp;</code> AND 2 <code>bool -&gt; bool -&gt; bool</code> <code>||</code> OR 2 <code>bool -&gt; bool -&gt; bool</code> <code>!</code> NOT 1 <code>bool -&gt; bool</code>"},{"location":"language-manual/#data","title":"Data","text":"Description <code>.</code> Record field access See Field access"},{"location":"language-manual/#algebraic-structures","title":"Algebraic structures","text":"Description <code>&lt;&gt;</code> Semigroup operator <code>\u2200a : a -&gt; a -&gt; a with Semigroup(a)</code>"},{"location":"language-manual/#function-composition-and-pipelining","title":"Function composition and pipelining","text":"Description Type <code>&gt;&gt;</code> Forward composition <code>(a -&gt; b) -&gt; (b -&gt; c) -&gt; a -&gt; c</code> <code>&lt;&lt;</code> Reverse composition <code>(b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code> <code>|.</code> Reverse application <code>a -&gt; (a -&gt; b) -&gt; b</code> <code>.|</code> Forward application <code>(a -&gt; b) -&gt; a -&gt; b</code>"},{"location":"language-manual/#list-operations","title":"List operations","text":"Description Type <code>++</code> List concatenation <code>\u2200a : List&lt;a&gt; -&gt; List&lt;a&gt; -&gt; List&lt;a&gt;</code>"},{"location":"language-manual/#string-manipulation","title":"String manipulation","text":"Description Type <code>+++</code> String concatenation <code>string -&gt; string -&gt; string</code>"},{"location":"language-manual/#comments","title":"Comments","text":"<p>There are two types of comments:</p> <ul> <li>Single-line comments begin with a double forward slash (<code>//</code>) and extend to the end of the line. Any text following <code>//</code> is considered a comment.</li> </ul> <pre><code>  foo(1)  // Leave any comments about this comment in the comment field below.\n</code></pre> <ul> <li>Multi-line comments (also called block comments) start with <code>/*</code> and end with <code>*/</code>. All text between these delimiters is treated as a comment.</li> </ul> <pre><code>  /* This is a long comment. It can extend over multiple \n     lines. It may or may not contain ASCII art depicting,\n     for example, a giraffe. \n\n         (\\-/)\n        (:O O:)\n         \\   /o\\\n          | |\\o \\  \n          (:) \\ o\\  \n               \\o \\--_ \n               ( o O\n               (  O\n  */\n  fun sqrt(d : double) =\n    ...\n</code></pre>"},{"location":"language-manual/#types","title":"Types","text":""},{"location":"language-manual/#built-in-language-primitives","title":"Built-in language primitives","text":"<p>Coal provides the following built-in types:</p> Type Description Example values <code>bool</code> Booleans <code>true</code>, <code>false</code> <code>char</code> A single Unicode character <code>'a'</code>, <code>'b'</code>, <code>'\ud83e\udd16'</code>, ... <code>float</code> Single precision floating point numbers <code>3.1519f</code> <code>double</code> Double precision floating point numbers <code>3.141592653589793</code> <code>int32</code> 32-bit integers <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, ... <code>int64</code> 64-bit integers <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, ... <code>bignum</code> Arbitrary precision integers <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, ... <code>string</code> UTF-8 text <code>\"Hello, \u2728 world!\"</code> <code>unit</code> Singleton type <code>()</code> <code>void</code> The uninhabited type <code>nat</code> Natural numbers (Peano arithmetic) <code>Zero</code>, <code>Succ(Zero)</code>, ..."},{"location":"language-manual/#natural-numbers","title":"Natural numbers","text":"<p>Recursion in Coal is closely tied to pattern matching: we peel off layers of a recursively defined data structure step by step, until reaching its base case. This works naturally with lists, trees, and other algebraic data types. Ordinary machine integers (<code>int32</code>, <code>int64</code>), however, cannot be pattern matched on in such a manner. Nevertheless, we often want to use numbers in recursive computations \u2014 for example, when repeating an action, or simulating the behavior of loops in imperative languages. To describe numbers in a way compatible with recursion, we find some inspiration from the standard axiomatization of the natural numbers:</p> <p>Every natural number is either zero or the successor of another natural number.</p> <p>This is known as the Peano construction of the natural numbers, named after the Italian mathematician Giuseppe Peano. In code, the Peano numbers are expressed as the built-in type <code>nat</code>:</p> <pre><code>type nat\n = Zero\n | Succ(nat)\n</code></pre> <p>The number five, for example, can then be written:</p> <pre><code>Succ(Succ(Succ(Succ(Succ(Zero)))))\n</code></pre> <p>This representation makes it possible to use numbers directly in patterns, just like with other algebraic data types:</p> <pre><code>  match(n : nat) {\n    | Zero    =&gt; \"yay\"\n    | Succ(_) =&gt; \"nay\"\n  }\n</code></pre> <p>Writing numbers in this style quickly becomes impractical, however. To make working with naturals convenient (and efficient), the compiler internally represents values of type <code>nat</code> as ordinary integers. Converting between the two views is called packing and unpacking. These are constant time (O(1)) operations:</p> <pre><code>pack   : int32 -&gt; nat\nunpack : nat -&gt; int32\n</code></pre>"},{"location":"language-manual/#unit","title":"Unit","text":"<p>The <code>unit</code> type has only a single value, written as an empty pair of parentheses: <code>()</code>. At first glance this type may appear to serve no purpose, but it has several practical uses. For example, it is often useful to indicate that a function doesn't take any meaningful input. In C, we might write the following function:</p> <pre><code>int five() {\n  /* ... */\n\n  return 5;\n}\n</code></pre> <p>This is where the <code>unit</code> type comes in handy:</p> <pre><code>fun five(() : unit) : int32 = 5\n</code></pre>"},{"location":"language-manual/#two-pairs-of-parentheses-for-the-price-of-one","title":"Two pairs of parentheses for the price of one","text":"<p>Removing the type annotation, the above becomes <code>fun five(()) = 5</code>, which is perfectly valid. But since an expression like <code>five()</code> doesn\u2019t have any other meaningful interpretation, the compiler accepts this as a shorthand for the slightly awkward-looking double parentheses:</p> <pre><code>fun five() = 5   // i.e., fun five(() : unit) = 5\n</code></pre> <p>Similarly, when calling a function that only takes a unit value as argument, the extra parentheses can be omitted:</p> <pre><code>let \n  x = \n    five()   // we could have written five(()) here, but less is more\n  in\n    x + 5\n</code></pre> <p>Keep in mind that this only works with <code>unit</code>. For non-empty tuples, you still need the extra parentheses:</p> <pre><code>fun fst4((fst, _, _, _)) = fst\n</code></pre>"},{"location":"language-manual/#list","title":"List","text":"<p>A list is an ordered collection in which all elements share the same type. Lists are one of the most fundamental data structures in functional programming. They are commonly used to store and manipulate collections of data, and serve as a building block for many higher-level abstractions.</p> <p>In Coal, list literals are written as a sequence of comma-separated expressions enclosed in square brackets:</p> <pre><code>[&lt;expr_1 : t&gt;, &lt;expr_2 : t&gt;, ..., &lt;expr_n : t&gt;] : List&lt;t&gt;\n</code></pre> <p>For example:</p> <pre><code>[1, 1, 2, 5, 14, 42, 132, 429] : List&lt;int32&gt;\n</code></pre> <p>Lists are defined inductively and implemented internally as a singly linked list. This means that a list of type <code>List&lt;a&gt;</code> is either:</p> <ol> <li>the empty list <code>[]</code>; or</li> <li>a value of type <code>a</code> (the head) followed by another list of type <code>List&lt;a&gt;</code> (the tail).</li> </ol> <p>In pseudo-code:</p> <pre><code>type List&lt;a&gt;\n  = []\n  | a :: List&lt;a&gt;\n</code></pre> <p>Here <code>::</code> denotes the cons-operator, which constructs a new list by prepending an element to an existing list.</p> <p>Lists are deconstructed using pattern matching. For example, the following function removes the first element from a list if it happens to be a zero:</p> <pre><code>  fun remove_head_if_zero(list) = \n    match(list) {\n      | [] =&gt; []\n      | head :: tail =&gt;\n          if (head == 0)\n            then tail     // remove the first element, if it is zero\n            else list     // otherwise return the original list\n    }\n</code></pre> <p>This style of unpacking data is common with all algebraic data types (see Pattern matching).</p> <p>You can also match lists using literal patterns. The following example matches a list of exactly three elements and checks if they form a Pythagorean triple:</p> <pre><code>  fun is_pythagorean(numbers) =\n    match(numbers) {\n      | [a, b, c] =&gt;\n          a^2 + b^2 == c^2 || \n          a^2 + c^2 == b^2 || \n          b^2 + c^2 == a^2\n      | _ =&gt;\n          false\n    }\n</code></pre>"},{"location":"language-manual/#common-list-operations","title":"Common list operations","text":"<p>The function <code>length</code> returns the number of elements in a list:</p> <pre><code>length([0, 1, 2, 3, 4])   // returns 5\n</code></pre> <p>Its type is:</p> <pre><code>length : List&lt;a&gt; -&gt; nat\n</code></pre> <p>Since lists are laid out in memory as linked nodes connected by pointers, the time complexity of many list operations, including <code>length</code>, is O(n).</p>"},{"location":"language-manual/#head-tail-and-uncons","title":"Head, tail, and uncons","text":"<ul> <li><code>head</code> returns the first element of a list, wrapped in an <code>Option</code> (described below) to account for the empty list.</li> <li><code>tail</code> returns all elements except the first, also as an <code>Option</code>.</li> <li><code>uncons</code> combines the two: it returns both the head and tail as a tuple, or <code>None</code> if the list is empty. In a sense, it undoes what the cons (<code>::</code>) constructor does.</li> </ul> <p>These functions take constant (O(1)) time.</p> <pre><code>head : List&lt;a&gt; -&gt; Option&lt;a&gt;\ntail : List&lt;a&gt; -&gt; Option&lt;List&lt;a&gt;&gt;\nuncons : List&lt;a&gt; -&gt; Option&lt;(a, List&lt;a&gt;)&gt;\n</code></pre> <p>Function pipelining</p> <p>The operator <code>|.</code> is used in the following examples. It is an infix operator that performs function application, but with the arguments reversed. So, for example, the expression  <pre><code>  xs |.map(f)\n</code></pre> is really syntactic sugar for <code>map(f, xs)</code>. This operator is very convenient when chaining together multiple function calls. Suppose we have the following basic drawing API:</p> <pre><code>circle       : Config -&gt; Shape\nfill         : string -&gt; Shape -&gt; Shape\nset_position : float -&gt; float -&gt; Shape -&gt; Shape\ndraw_shape   : Shape -&gt; Canvas -&gt; Canvas\n</code></pre> <p>To describe a sequence of steps that creates a circle, sets properties such as its color and position, and finally places it on the canvas, we would normally write:</p> <pre><code>draw_shape(set_position(10.0f, 5.0f, fill(\"blue\", circle({ radius = 5.0f }))), canvas)\n</code></pre> <p>Using the reverse function application operator, we could instead write the above in a more readable pipeline-style:</p> <pre><code>circle({ radius = 5.0f })\n  |.fill(\"blue\")\n  |.set_position(10.0f, 5.0f)\n  |.flipped(draw_shape, canvas)\n</code></pre>"},{"location":"language-manual/#take-drop-and-slice","title":"Take, drop and slice","text":"<p>Use <code>take</code> to get another list with the first n elements from a given list:</p> <pre><code>take : nat -&gt; List&lt;a&gt; -&gt; List&lt;a&gt;\n</code></pre> <p>For example:</p> <pre><code>[1, 2, 3, 4, 5, 6, 7] |.take(3)     // [1, 2, 3]\n</code></pre> <p>Note that, if the list\u2019s length is less than the requested number of elements, then <code>take</code> returns the entire list. So, for example, <code>take(5, [1, 2, 3])</code> returns <code>[1, 2, 3]</code>. As expected, <code>take(0)</code> always returns an empty list.</p> <p>The function <code>drop</code> removes the first n elements from a list.</p> <pre><code>drop : nat -&gt; List&lt;a&gt; -&gt; List&lt;a&gt;\n</code></pre> <p>For example:</p> <pre><code>[1, 2, 3, 4, 5, 6, 7] |.drop(3)     // [4, 5, 6, 7]\n</code></pre> <p>If you attempt to drop a greater number of elements than what the list contains, <code>drop</code> returns an empty list.</p> <p>Combining <code>drop</code> and <code>take</code> allows you to obtain a range of elements from within a list:</p> <pre><code>[1, 2, 3, 4, 5, 6, 7] \n  |.drop(2)\n  |.take(3)\n\n// == [3, 4, 5]\n</code></pre> <p>The function <code>slice</code> does exactly this, in a way that allows you to specify the range of elements to extract from the input list:</p> <pre><code>slice : nat -&gt; nat -&gt; List&lt;a&gt; -&gt; List&lt;a&gt;\n</code></pre> <pre><code>[1, 2, 3, 4, 5, 6, 7] |.slice(2, 5)\n// == [1, 2, 3, 4, 5, 6, 7] |.drop(2) |.take(5 - 2)\n// == [3, 4, 5]\n</code></pre>"},{"location":"language-manual/#list-concatenation","title":"List concatenation","text":"<p>The list concatenation operator (<code>++</code>) appends one list to the end of another, resulting in a new list.</p> <pre><code>  let s = [\"Khufu\", \"Hatshepsut\", \"Akhenaten\"] ++ [\"Tutankhamun\"]\n</code></pre> <p>Note: The time complecity of <code>++</code> is linear (O(n)) in the length of the first list.</p>"},{"location":"language-manual/#useful-higher-order-list-functions","title":"Useful higher-order list functions","text":"<p>These are functions that take some other function as input and modify the list in some way based on the behavior of the given function.</p>"},{"location":"language-manual/#mapping-over-a-list","title":"Mapping over a list","text":"<p>The function <code>map</code> applies a function to each element of a list.</p> <p>For example:</p> <pre><code>[0, 1, 2, 3, 4] |.map(fn(x) =&gt; 2 ^ x)       // [1, 2, 4, 8, 16]\n</code></pre> <p>The type of <code>map</code> is:</p> <pre><code>map : (a -&gt; b) -&gt; List&lt;a&gt; -&gt; List&lt;b&gt;\n</code></pre> <p>Mapping and the <code>Functor</code> trait</p> <p>The actual type of <code>map</code> is more general than the specialized <code>List</code> version above. In fact, any value of type <code>f&lt;a&gt;</code> can be mapped over, as long as <code>f</code> implements the <code>Functor</code> trait:</p> <pre><code>map : (a -&gt; b) -&gt; f&lt;a&gt; -&gt; f&lt;b&gt; with Functor&lt;f&gt;\n</code></pre> <p>We can think of this more abstractly as \"transforming values inside a fixed context.\" In mathematical terms, this corresponds to a structure-preserving map, also known as a homomorphism.  Homomorphisms are the topic of study in category theory. It is also in category theory that we find the origin of functors. A functor, in this context, is a mapping between categories \u2014 one that sends objects and morphisms from one category to another (subject to certain laws). </p> <p>There are two ways to interpret <code>map</code>; we can think of it as a function that applies the function argument to a value of type <code>a</code>, in the <code>f</code>-context, which could be a list of values, or an optional. The other is that <code>map</code> takes some function <code>a -&gt; b</code> and lifts it into one that acts on <code>f</code>-values \u2014 that is, one of type <code>f&lt;a&gt; -&gt; f&lt;b&gt;</code>. This second interpretation is more in line with the definition of a functor in category theory. In programming languages, objects correspond to types, and morphisms are simply functions. We then have:</p> <pre><code>a           ==&gt;  f&lt;a&gt;                         // The functor transforms objects\nz : a -&gt; b  ==&gt;  map(z) : f&lt;a&gt; -&gt; f&lt;b&gt;        // and functions\n</code></pre> <p>Functors are expected to obey the following two laws:</p> <p>1. Identity law</p> <pre><code>map(id) == id\n</code></pre> <p>This says that mapping the identity function over a functor doesn\u2019t change the structure or its contents. </p> <p>2. Composition law</p> <pre><code>map(f &lt;&lt; g) == map(f) &lt;&lt; map(g)     // The operator `&lt;&lt;` denotes function composition, so `f &lt;&lt; g = f(g(x)))`.\n</code></pre> <p>This law ensures that mapping the composition of two functions is the same as first mapping one function and then the other. In other words, functors preserve function composition. </p> <p>Together, these laws guarantee that mapping behaves consistently: the shape of the container is unchanged, and each element inside the context is transformed individually, and in the same way as if the function were applied directly to that element. These laws aren\u2019t enforced by the compiler, but following them is always a good idea. </p>"},{"location":"language-manual/#filtering-a-list","title":"Filtering a list","text":"<p>Filtering is a technique for removing all elements of a list, except those that meet a given condition.</p> <p>For example:</p> <pre><code>[0, 1, 2, 3, 4] |.filter(fn(x) =&gt; x &gt; 2)    // [3, 4] \n</code></pre> <p>The type of <code>filter</code> is:</p> <pre><code>filter : (a -&gt; bool) -&gt; List&lt;a&gt; -&gt; List&lt;a&gt;\n</code></pre> <p>That is, <code>filter</code> takes a predicate and a list as input, and returns a new list with only the elements that return <code>true</code> for the predicate.</p>"},{"location":"language-manual/#reducing-a-list","title":"Reducing a list","text":"<p>The higher-order function <code>reduce</code> takes a list and combines its elements into a single result. A common example is reducing a list of numbers to a single value by repeatedly applying an operation, such as summing each element with a running total:</p> <pre><code>let sum = reduce(fn(n, a) =&gt; n + a, 0, [1, 2, 3])\n</code></pre> <p>The operation described here is also commonly referred to as a fold. That name is not used, however, since it is a reserved language keyword in Coal. Along with the special <code>@</code>-pattern syntax, it provides the foundation for implementing recursive functions, including <code>reduce</code>. This is explored in detail in Recursion, corecursion, and codata.</p> <p>The type of <code>reduce</code> is:</p> <pre><code>reduce : (e -&gt; a -&gt; a) -&gt; a -&gt; List&lt;e&gt; -&gt; a\n</code></pre> <ul> <li>The first argument is a function that combines an element of type <code>e</code> with an accumulator of type <code>a</code> to produce a new accumulator.</li> <li>The second argument is the initial value of the accumulator.</li> <li>The third argument is the list to reduce.</li> </ul>"},{"location":"language-manual/#examples-of-using-reduce","title":"Examples of using <code>reduce</code>","text":"<p>Concatenating strings:</p> <pre><code>let words = [\"Hello\", \" \", \"world\", \"!\"]\nlet sentence = reduce(fn(w, a) =&gt; w +++ a, \"\", words)\n// sentence = \"Hello world!\"\n</code></pre> <p>Finding the maximum element:</p> <pre><code>let max_val = reduce(fn(n, a) =&gt; if n &gt; a then n else a, 0, [3, 7, 2, 9])\n// max_val = 9\n</code></pre> <p>Counting elements satisfying a condition:</p> <pre><code>let numbers = [1, 2, 3, 4, 5]\nlet number_of_evens = reduce(fn(n, a) =&gt; if n % 2 == 0 then a + 1 else a, 0, numbers)\n// number_of_evens = 2\n</code></pre>"},{"location":"language-manual/#list-predicates","title":"List predicates","text":"<p>A predicate is a function that tests for some condition with respect to its argument and returns <code>true</code> or <code>false</code>. By convention, functions that serve this purpose are often prefixed with <code>is_</code>. The below predicates are available in the standard <code>List</code> package:</p> <pre><code>is_empty     : List&lt;a&gt; -&gt; bool\nis_nonempty  : List&lt;a&gt; -&gt; bool\nis_singleton : List&lt;a&gt; -&gt; bool\n</code></pre>"},{"location":"language-manual/#is_empty","title":"<code>is_empty</code>","text":"<p>A common operation on lists is to check if a list is empty or not. This is what the function <code>is_empty</code> does. </p> <pre><code>is_empty([])                                   // true\nis_empty([\"wheat\", \"oats\", \"rye\", \"barley\"])   // false\n</code></pre>"},{"location":"language-manual/#is_nonempty","title":"<code>is_nonempty</code>","text":"<p>This function is the opposite of <code>is_empty</code>. That is: </p> <pre><code>is_nonempty(xs) &lt;==&gt; ! is_empty(xs)\n</code></pre>"},{"location":"language-manual/#is_singleton","title":"<code>is_singleton</code>","text":"<p>This function returns <code>true</code> when the input list has precisely one element. </p> <pre><code>is_singleton([\"oats\"])                             // true  \nis_singleton([])                                   // false\nis_singleton([\"wheat\", \"oats\", \"rye\", \"barley\"])   // false\n</code></pre>"},{"location":"language-manual/#option","title":"Option","text":"<p>The <code>Option</code> type is a built-in algebraic data type that represents optional values \u2014 values that may or may not be present. This type is called <code>Maybe</code> in Haskell and is similar to <code>Option</code> in languages like Rust or Scala. </p> <pre><code>type Option&lt;a&gt;\n  = Some(a)\n  | None\n</code></pre> <p>Since <code>match</code> statements in Coal need to be exhaustive, <code>Option</code> is useful to express the fact that a value cannot be produced in certain cases. For example, let\u2019s say that we are trying to define a function <code>head</code>, returning the first element of a list:</p> <pre><code>  fun head(list : List&lt;a&gt;) : a =\n    match(list) {\n      | head :: _ =&gt; head\n      | [] =&gt; // \ud83d\udca5 What should I return here?\n    }\n</code></pre> <p>The type of this function would be:</p> <pre><code>head : List&lt;a&gt; -&gt; a\n</code></pre> <p>We can read this type as: Given any type <code>a</code> and a list of elements of this type, return an <code>a</code> value. That is to say; we know nothing about <code>a</code>, except that the list\u2019s elements has this type.  Therefore, if the input list is empty, then we have nothing to look at. <code>Option</code> solves this problem. The <code>head</code> function provided by the standard <code>List</code> package is defined in the following way: </p> <pre><code>  fun head(list : List&lt;a&gt;) : Option&lt;a&gt; =\n    match(list) {\n      | head :: _ =&gt; Some(head)\n      | [] =&gt; None\n    }\n</code></pre>"},{"location":"language-manual/#tuples","title":"Tuples","text":"<p>Just like lists, tuples are ordered sequences of values. Unlike lists, however, a tuple\u2019s length is fixed (i.e. determined at compile-time), and its elements can have different types. In code, a tuple is written as a comma-separated sequence of expressions enclosed in parentheses:</p> <pre><code>(&lt;expr_1 : t_1&gt;, &lt;expr_2 : t_2&gt;, ..., &lt;expr_n : t_n&gt;) : (t_1, t_2, ..., t_n)\n</code></pre> <p>For example:</p> <pre><code>(10, \"covfefe\", false)  // The type of this tuple is: (int32, string, bool)\n</code></pre> <p>Tuples of length two and three are often called pairs and triples, respectively. There is no singleton tuple type \u2014 a single value in parentheses is just the value itself:</p> <pre><code>(42)  // Not a tuple -- just the integer 42\n</code></pre> <p>The empty tuple does exist, and has special meaning. It is written <code>()</code> and is known as the unit value. The type of <code>()</code> is <code>unit</code>. (See Built-in language primitives for more details.)</p> <pre><code>()            : unit                           // unit value\n(1, 2)        : (int32, int32)                 // 2-tuple\n(1, 2, 3)     : (int32, int32, int32)          // 3-tuple\n(1, 2, 3, 4)  : (int32, int32, int32, int32)   // 4-tuple\n// ...\n</code></pre> <p>As with other data types, tuples can be deconstructed through pattern matching:</p> <pre><code>  fun fst3((fst, _, _) : (a, b, c)) : a = fst\n  fun snd3((_, snd, _) : (a, b, c)) : b = snd\n  fun thd3((_, _, thd) : (a, b, c)) : c = thd \n</code></pre>"},{"location":"language-manual/#tuples-and-currying","title":"Tuples and currying","text":"<p>To specify a tuple as the only argument to a function, you need to use an extra pair of parentheses:</p> <pre><code>fun add((a, b)) = a + b\n\nlet five = add((1, 4))\n</code></pre> <p>The <code>curry</code> and <code>uncurry</code> combinators convert an uncurried function into a curried one, and vice versa.</p> <pre><code>curry   : ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c\nuncurry : (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c\n</code></pre> <p>Here is how <code>curry</code> is used with the uncurried version of <code>add</code>, to change it into curried form.</p> <pre><code>let five = curry(add, 1, 4)         // or (curry(add))(1, 4)\n</code></pre>"},{"location":"language-manual/#records","title":"Records","text":"<p>Records are unordered collections of name\u2013value pairs, where the values can be of any type, including other records. In Coal, records are first-class values. They are suitable for representing structured data with multiple properties, or nested objects. A record expression is written as a sequence of comma-separated fields enclosed in curly braces. Each field consists of a name, called the label, paired with a value. The two are separated by an equals sign (<code>=</code>):</p> <pre><code>{ \n  name = \"Robert Sixkiller\", \n  shoe_size = 43.0f, \n  privileges = [\"read\", \"edit\", \"karaoke\"]\n}\n</code></pre> <p>The corresponding type for the above record is:</p> <pre><code>{ name : string, shoe_size : float, privileges : List&lt;string&gt; }\n</code></pre> <p>The type of a record resembles the expression itself, except that each field is written as a label followed by its type. Instead of an equals sign, a colon (<code>:</code>) separates the label and the type.</p> <p>Since the order of fields is irrelevant, the following two records are considered identical:</p> <pre><code>{ x = 1, y = 2 }\n{ y = 2, x = 1 }\n</code></pre> <p>The naming rules for labels are the same as for variables: labels must consist of alphanumeric characters or underscores (<code>_</code>), and the first character cannot be a digit.</p>"},{"location":"language-manual/#field-access","title":"Field access","text":"<p>The contents of a record field can be obtained using the field-access operator, which is simply a dot (<code>.</code>) followed by the field\u2019s label:</p> <pre><code>let language = { name = \"Java\", paradigm = \"OOP\" }\n  in language.name\n</code></pre>"},{"location":"language-manual/#extending-records","title":"Extending records","text":"<p>Records in Coal are extensible, meaning that new fields can be added to a record at run time. For example:</p> <pre><code>fun tagged(rec, t : string) = { tag = t | rec }  \n</code></pre> <p>This function accepts two arguments: an existing record <code>rec</code> and a string <code>t</code>. It returns a copy of <code>rec</code> augmented with a new field <code>tag</code> which assumes the value of <code>t</code>. The pipe symbol (<code>|</code>) is an infix operator that takes the record on the right-hand side and extends it with the fields on the left.</p> <p>For example, if we define a record <code>r = { day = \"monday\", humidity = 73.5 }</code> and apply <code>tagged(r, \"wet\")</code>, we obtain a new record:</p> <pre><code>{ day = \"monday\", humidity = 73.5, tag = \"wet\" }\n</code></pre> <p>What makes this especially useful is that the type of the original record does not matter; its labels and field types need not be known at compile time.</p> <p>The left-hand side of the pipe is itself a list of fields, so any number of fields can be added at once:</p> <pre><code>{ a = 1, b = 2 | { c = 3 } } \n  == { a = 1 | { b = 2 | { c = 3 } } } \n  == { a = 1 | { b = 2, c = 3 } }\n  =&gt; { a = 1, b = 2, c = 3 }  \n</code></pre>"},{"location":"language-manual/#open-and-closed-records","title":"Open and closed records","text":"<p>Here is the function signature for <code>tagged</code> again, this time with added type annotations:</p> <pre><code>tagged(rec : { | r }, t : string) : { tag : string | r } = \n  { tag = t | rec }\n</code></pre> <p>These types look a bit different from earlier examples. Here, the pipe (<code>|</code>) also appears at the type level. It serves a similar purpose: combining fields with an existing record type. The type variable <code>r</code> represents a row, which can be thought of as a type-level list of fields. A record type of this form is called open. By contrast, a closed record type explicitly lists all its fields. The following example illustrates the difference. Suppose we want to represent GPS coordinates with two fields, <code>lat</code> and <code>lng</code>:</p> <pre><code>fn(p : { lat : float, lng : float }) =&gt; p.lat\n</code></pre> <p>In this example, the function requires its argument <code>p</code> (a record) to have exactly two fields: <code>lat</code> and <code>lng</code>, both of type <code>float</code>. This type is closed.</p> <pre><code>fn(p : { lat : float, lng : float | q }) =&gt; p.lat\n</code></pre> <p>This function, on the other hand, is polymorphic in the row variable <code>q</code>. It accepts any record that includes <code>lat</code> and <code>lng</code> (both floats), regardless of any additional fields. For instance, all of the following are valid:</p> <ul> <li><code>{ lat =-3.067425, lng = 37.355625, alt = 5895 }</code> , </li> <li><code>{ location = \"Great Pyramid\", time = \"2024-09-15T10:57:19Z\", lat = 29.9792, lng = 31.1342 }</code>, and </li> <li><code>{ lat = 0.0, lng = 1.0 }</code>,</li> </ul> <p>This type is open. The general format of an open record type is </p> <pre><code>{ &lt;label_1&gt; : &lt;t_1&gt;, &lt;label_2&gt; : &lt;t_2&gt;, ..., &lt;label_n&gt; : &lt;t_n&gt; | &lt;r&gt; },\n</code></pre> <p>for some n \u2265 0. Recall the earlier <code>tagged</code> example and the type of the argument <code>rec</code> in that function:</p> <pre><code>rec : { | r }\n</code></pre> <p>In this type, the variable <code>r</code> captures all fields of the input record, so n is zero. This explains the somewhat unusual-looking type <code>{ | r }</code>.</p>"},{"location":"language-manual/#pattern-matching-over-records","title":"Pattern matching over records","text":"<p>As with other data types, it is possible to pattern match on records. In this context, the right-hand side of a field acts as the binding pattern used to match the sub-expression. The simplest case is to bind a field directly to a variable:</p> <pre><code>  fun full_name({ first_name = fn, last_name = ln }) = fn +++ \" \" +++ ln \n</code></pre>"},{"location":"language-manual/#deconstructing-records","title":"Deconstructing records","text":"<p>The pipe (<code>|</code>) operator allows you to deconstruct records by matching against a subset of their fields:</p> <pre><code>  fun get_name({ name = n | _ }) = n\n</code></pre> <p>The right-hand side pattern must be either a variable or a wildcard (<code>_</code>). If you use a variable here, it will capture the remainder of the record (all fields not explicitly matched). A common use case is to remove one or more fields from a record. For example:</p> <pre><code>  fun drop_name({ name = _ | fields } : { name : string | q }) : { | q } = fields\n</code></pre> <p>Here, the name field is removed and a record with all remaining fields are returned.</p> <p>If you only need to retrieve a single field, the dot syntax (<code>record.field</code>) is simpler and more concise. Pattern matching becomes necessary when you want to extract multiple fields at once, remove fields, or work with the remainder of a record.</p>"},{"location":"language-manual/#updating-a-field","title":"Updating a field","text":"<p>By combining field extension with pattern matching, you can replace an existing field in a record. For instance, here is a function that updates the <code>tag</code> field:</p> <pre><code>  fun set_tag({ tag = _ | fields }, new_tag : string) =\n    { tag = new_tag | fields }    \n</code></pre> <p>This proceeds in two steps: first remove the old field using pattern matching, then reinsert it with the new value. With type annotations:</p> <pre><code>  fun set_tag(\n    { tag = _ | fields } : { tag : string | r }, \n    new_tag : string\n  ) : { tag : string | r } = \n    { tag = new_tag | fields }\n</code></pre> <p>This function requires not only that the <code>tag</code> field is present, but also that it has the expected type. For example, <code>{ tag = false }</code> would be rejected, since <code>tag</code> is required to have type <code>string</code>.</p>"},{"location":"language-manual/#pattern-matching","title":"Pattern matching","text":"<p>The <code>match</code> expression in Coal is used to deconstruct data based on its shape, effectively reversing what the data constructors of algebraic data types do. It allows you to branch on the structure of a value and directly bind its components to variables. For example:</p> <pre><code>  type Shape = Rectangle(float, float) | Circle(float)\n\n  fun area(shape) : float =\n    match(shape) {\n      | Rectangle(w, h) =&gt; w * h\n      | Circle(r)       =&gt; pi * r^2\n    }\n</code></pre> <p>A case in a match expression is called a clause and consists of a pattern on the left and an expression on the right. Pattern matching proceeds by checking each clause in order until it finds one whose pattern matches the value. The corresponding right-hand side expression is then evaluated, with any variables in the pattern bound to the matched sub-components.</p> <pre><code>  match(list : List&lt;int32&gt;) {\n    | [a]       =&gt; a\n    | [a, _]    =&gt; a\n    | [a, _, _] =&gt; a\n    | _         =&gt; 0\n  }\n</code></pre> <p>Variables introduced by a pattern are only in scope in the corresponding right-hand side expression:</p> <pre><code>  match(opt) {\n    | Some(x) =&gt; x + 1  // x is bound here\n    | None    =&gt; 0      // x is not in scope here\n  }\n</code></pre> <p>Patterns can take several forms, including data constructors, literals, tuples, records, variables, wildcards, or combinations of these: </p> <pre><code>  match(shape) {\n    | Rectangle(0.0, _) =&gt; \"flat rectangle\"\n    | Rectangle(w, h)   =&gt; \"rectangle with width \" +++ show(w)\n  }\n</code></pre> <p>See below for a complete list of available patterns. </p>"},{"location":"language-manual/#totality-requirement","title":"Totality requirement","text":"<p>For a function to be total, it must be defined for all inputs of its corresponding type. A consequence of this in the context of <code>match</code> expressions is that all possible cases for a type need to be covered by the patterns. In other words, the patterns must be exhaustive. If a case is missing, the compiler will reject the program. </p> <p>For example, the following function</p> <pre><code>  fun head(input) =\n    match(input) {\n      | x :: xs =&gt; x\n    }\n</code></pre> <p>will produce an error:</p> <pre><code>4:5:\n  |\n  |     match(input) {\n  |     ^^^^^^^^^^^^^^\n  |       | x :: xs =&gt; x\n  | ^^^^^^^^^^^^^^^^^^^^\n  |     }\n\nNon-exhaustive patterns\n</code></pre>"},{"location":"language-manual/#wildcard-patterns","title":"Wildcard patterns","text":"<p>A wildcard pattern is a pattern that matches any value without binding it to a name and is written as an underscore (<code>_</code>). These are often useful to guarantee exhaustiveness in <code>match</code> expressions. For instance, we can use literal patterns along with a wildcard when matching on integers:</p> <pre><code>  fun describe_int(n : int32) : string =\n    match(n) {\n      | 0 =&gt; \"zero\"\n      | 1 =&gt; \"one\"\n      | _ =&gt; \"something else\"\n    }\n</code></pre>"},{"location":"language-manual/#lambda-match","title":"Lambda match","text":"<p>A lambda match is a special syntax that lets you get rid of the variable in a <code>match</code> expression. For example, this expression:</p> <pre><code>  match {\n    | [] =&gt; true\n    | _ =&gt; false \n  }\n</code></pre> <p>is a shorthand version of this:</p> <pre><code>  fn(val) =&gt;\n    match(val) {\n      | [] =&gt; true\n      | _ =&gt; false\n    }\n</code></pre>"},{"location":"language-manual/#supported-patterns","title":"Supported patterns","text":"Type Example Description Constructor <code>Color(r, g, b)</code> Matches a value built with a specific data constructor, binding sub-components to variables. Variable <code>x</code> Matches any value and binds it to the variable. Wildcard <code>_</code> Ignores the matched value (see above). Literal <code>\"Hello\"</code>, <code>0</code>, <code>()</code> Matches values that are exactly equal to the given literal. List constructor <code>x :: xs</code> Matches a list by separating it into head and tail. List literal <code>[f, s, t]</code> Matches a list of fixed length with elements matching the given sub-patterns. Tuple <code>(lhs, rhs)</code> Matches a tuple by decomposing it into its components. Record <code>{ name = n \\| _ }</code> Matches a record by specifying patterns for one or more fields. See Pattern matching over records for details. As <code>(lhs, _) as pair</code> Matches the inner pattern, while also binding the entire value to a variable. @ <code>Succ(@n)</code> Fold recursion. See Recursion, corecursion, and codata. Or <code>1 or 2</code> Matches if the value satisfies at least one of the given alternative patterns."},{"location":"language-manual/#traits","title":"Traits","text":"<p>A trait describes a collection of functions that must be defined for a given type.</p> <pre><code>trait &lt;name&gt;(&lt;type_parameter&gt;) {\n  &lt;definition_1&gt;: &lt;type_1&gt; \n  &lt;definition_2&gt;: &lt;type_2&gt; \n  ...\n  &lt;definition_n&gt;: &lt;type_n&gt; \n}\n</code></pre> <p>By defining a set of behaviors as a trait, you can reuse the same functionality across all types that support it. This reduces duplication and encourages reusable code. Traits are conceptually similar to type classes in Haskell and a common analogy is to think of them as interfaces in object-oriented programming.</p> <p>The following example defines a trait with a single function, <code>compare</code>. This function takes two inputs a and b of the same type and returns a value to indicate if a is less than b (<code>Lt</code>), greater than (<code>Gt</code>), or if the two values are equal (<code>Eq</code>). In other words, this trait captures the notion of a total order on the type <code>t</code> (similar to Haskell\u2019s <code>Ord</code> type class).</p> <pre><code>trait Ordered&lt;t&gt; {\n  fun compare : t -&gt; t -&gt; Order   // where type Order = Lt | Gt | Eq\n}\n</code></pre> <p>Making a type support a trait comes down to defining an instance of the trait. An instance provides concrete implementations of all functions declared in the trait, specialized for the chosen type. For example, by instantiating the <code>Ordered</code> trait for <code>bool</code>, we define an ordering on the booleans:</p> <pre><code>instance Ordered&lt;bool&gt; {\n  fun compare(a, b) =\n    match((a, b)) {\n      | (false, true) =&gt; Lt\n      | (true, false) =&gt; Gt\n      | (_, _) =&gt; Eq\n    }\n}\n</code></pre> <p>Code that uses <code>compare</code> now works uniformly for all types that have an <code>Ordered</code> instance:</p> <pre><code>fun is_less_than(x : t, y : t) : bool with Ordered&lt;t&gt; =\n  compare(x, y) == Lt\n\n// is_less_than(3, 5)\n// is_less_than(false, true)\n</code></pre> <p>Type parameters, like <code>t</code> in the type of <code>is_less_than</code> are universally quantified. The <code>with</code> keyword introduces one or more constraints on type variables appearing in a type. In this case it demands that an instance of <code>Ordered</code> exists for the type substituted for <code>t</code>. We write the full type of <code>is_less_than</code> as: <code>t -&gt; t -&gt; bool with Ordered&lt;t&gt;</code>.</p>"},{"location":"language-manual/#higher-kinded-traits","title":"Higher-kinded traits","text":"<p>So far, the traits we\u2019ve looked at have all been of the form <code>T&lt;t&gt;</code>, where <code>t</code> is a placeholder for an ordinary type. Unlike these, a type constructor is a type-level function which takes one or more types as arguments and returns a type. That is, a type constructor on its own isn\u2019t really a type, until it is provided with all necessary type arguments. For example, in the type <code>Option&lt;int32&gt;</code>, <code>Option</code> is a type constructor with kind</p> <pre><code>* -&gt; *\n</code></pre> <p>where <code>*</code> denotes a proper type (i.e., a fully applied type with no parameters). We can read <code>Option : * -&gt; *</code> as:</p> <p>Option is a type constructor that takes a type as input and produces a type.</p> <p>This generalizes to constructors of higher kinds. For example, <code>Result&lt;e, a&gt;</code> has kind <code>* -&gt; * -&gt; *</code>.</p> <p>Traits can be parameterized by type constructors. Instead of <code>T&lt;t : *&gt;</code>, we then get a trait of the form <code>T&lt;f : * -&gt; ... -&gt; *&gt;</code>. A common example is the <code>Functor</code> trait, which abstracts the idea of mapping a function over some container-like structure:</p> <pre><code>trait Functor&lt;f : * -&gt; *&gt; {\n  map : (a -&gt; b) -&gt; f&lt;a&gt; -&gt; f&lt;b&gt;;\n}\n</code></pre> <p>The <code>Option</code> type forms a <code>Functor</code> in the following way:</p> <pre><code>// Make Option an instance of the Functor trait\ninstance Functor&lt;Option&gt; {\n  fun map(f, opt) =\n    match(opt) {\n      | Some(a) =&gt; Some(f(a))\n      | None =&gt; None\n    }\n}\n</code></pre> <p>This instance ensures that <code>map</code> can be used on <code>Option</code> values, just like on lists:</p> <pre><code>let times100 = fn(x) =&gt; x * 100\n\nmap(times100, Some(1))    // ==&gt; Some(100)\nmap(times100, [1, 2, 3])  // ==&gt; [100, 200, 300]\n</code></pre>"},{"location":"language-manual/#trait-inheritance","title":"Trait inheritance","text":"<p>A trait can declare that it depends on another trait by inheriting from it. The inheriting trait is then able to access to the methods of the parent trait, and build its own functionality on top of them. For example, the following instance defines how to display an <code>Option&lt;a&gt;</code> value, provided that there is already a way to display values of type <code>a</code>:</p> <pre><code>  trait Show&lt;Option&lt;a&gt;&gt; with Show&lt;a&gt; {\n    fun show(opt) =\n      match(opt) {\n        | Some(v) =&gt; \"Some(\" +++ show(v) +++ \")\"\n        | None =&gt; \"None\"\n      }\n  } \n</code></pre> <p>Here, the <code>Show&lt;Option&lt;a&gt;&gt;</code> instance inherits from <code>Show&lt;a&gt;</code>. The compiler will only accept this instance assuming a <code>Show</code> implementation for <code>a</code> is available. Inside the trait body, we can call <code>show(v)</code> on the inner value <code>v : a</code>. The parent trait <code>Show&lt;a&gt;</code> guarantees that <code>show</code> is defined for this type. In other words, the ability to show an <code>Option&lt;a&gt;</code> depends directly on the ability to show its element type <code>a</code>.</p>"},{"location":"language-manual/#recursion-corecursion-and-codata","title":"Recursion, corecursion, and codata","text":"<p>In most programming languages, a typical implementation of the factorial function looks something like this:</p> <pre><code>fun factorial(n : int32) =\n  if (n == 0)\n    then 1\n    else n * factorial(n - 1)\n</code></pre> <p>If we pass this function to the Coal compiler, it is rejected with the following error:</p> <pre><code>  |       else n * factorial(n - 1);\n  |                ^^^^^^^^^\n\nName not in scope: factorial\n</code></pre> <p>To call a function from itself in this way is not possible. Instead, recursion must be accomplished through a pattern know as a fold. A fold (or catamorphism) is a way to deconstruct data, layer by layer. It abstracts the notion of a structurally recursive computation over some algebraic data type. </p>"},{"location":"language-manual/#fold-syntax","title":"Fold syntax","text":"<p>In Coal, <code>fold</code> is a language keyword, not an ordinary function. Syntactically, it is similar to a <code>match</code> expression (explained here), but with one crucial difference: a <code>fold</code> carries built-in support for recursion. </p> <p>To implement the factorial function using a fold, we are going to use the <code>nat</code> data type, which defines the natural numbers recursively:</p> <pre><code>Zero, Succ(Zero), Succ(Succ(Zero)), ...\n</code></pre> <p>It is defined as:</p> <pre><code>type nat \n  = Zero \n  | Succ(nat)\n</code></pre> <p>This type is recursive because <code>nat</code> appears inside one of its own constructors. We mark this recursive position with the special symbol <code>@</code>:</p> <pre><code>type nat \n  = Zero \n  | Succ(@)\n</code></pre> <p>This location is significant since it is precisely where the <code>fold</code> mechanism will recurse. Using the special <code>@</code>-pattern syntax only available in <code>fold</code> expressions, we can now express the factorial function as:</p> <pre><code>  fun factorial(n : nat) =\n    fold(n) {\n      | Zero =&gt;\n          1\n      | Succ(@p) as m =&gt;\n          m * p\n    }\n</code></pre> <p>Here is how to unpack the meaning of this:</p> <ul> <li>In the base case <code>Zero</code>, the result is simply <code>1</code>.</li> <li>In the recursive case <code>Succ(@p) as m</code>:</li> <li><code>m</code> is bound to the current value being matched (e.g., <code>Succ(Succ(Zero))</code>),</li> <li><code>p</code> is bound to the result of recursively folding over the inner value \u2014 the one inside the constructor (<code>Succ</code>).</li> </ul> <p>So intuitively, <code>@p</code> behaves like \u201cthe result of recursively applying this same fold to the inner structure.\u201d In other words, the compiler performs the recursion for you.</p> <p>This produces the same behavior as if you could have written an explicitly recursive definition such as:</p> <pre><code>      | Succ(r) =&gt; Succ(r) * fold(r)\n</code></pre> <p>but without referring to the function by name.</p> <p>The fibonacci function can be implemented in the following way:</p> <pre><code>  fun fib(p : nat) =\n    let (res, _) =\n      fold(p - 1) {\n        | Zero =&gt; \n            (1 : nat, 1)\n        | Succ(@q) =&gt; \n            let \n              (m, n) = q\n            in \n              (n, m + n)\n      }\n    in\n      res\n</code></pre>"},{"location":"language-manual/#well-foundedness","title":"Well-foundedness","text":"<p>To ensure that recursion is well-founded (guaranteed to terminate), the use of <code>@</code>-patterns is restricted. Most importantly, they can only appear inside constructors. The reason for this is that a constructor\u2019s fields are always structurally smaller than the value being folded. Progress toward the base case is thereby guaranteed in each step.</p> <p>The following, for example, is invalid:</p> <pre><code>    fold(n) {\n      | @p =&gt; p\n    }\n</code></pre> <p>Here, <code>@p</code> appears at the top level, and not inside a constructor. This means that the fold would have no smaller sub-structure to recurse into.</p>"},{"location":"language-manual/#beyond-the-factorial","title":"Beyond the factorial","text":"<p>Folds can express a wide range of recursive computations over algebraic data types. For example, here is the implementation of <code>reduce</code> for lists:</p> <pre><code>  fun reduce(f, acc, list) =\n    fold(list, acc) {\n      x :: @rec =&gt;\n        fn(a) =&gt; rec(f(x, a))\n      [] =&gt;\n        fn(a) =&gt; a\n    }\n</code></pre> <p>This definition captures the standard way of consuming a list by repeatedly applying a function (<code>f</code>) to its elements and an accumulator. The recursive descent through the list happens implicitly \u2014 the programmer specifies only what to do at each layer.</p> <p>Note</p> <p>Instead of dealing with recursive computations directly, it is often easier and safer to build on existing combinators and higher-order functions. For example, we can express the factorial function in the following way:</p> <pre><code>let factorial = product &lt;&lt; enum_to  // product of numbers 1, 2, ..., n\n</code></pre> <p>Here, <code>enum_to</code> generates the list <code>[1, 2, ..., n]</code>, and <code>product</code> multiplies its elements.</p>"},{"location":"language-manual/#mutual-recursion","title":"Mutual recursion","text":"<p>Even though the <code>fold</code> expression syntax is applicable to a wide range of algorithms, there are cases where it falls short. Let\u2019s take another look at the JSON data type devised earlier:</p> <pre><code>  type JsonValue\n    = Null\n    | Bool(bool)\n    | Number(double)\n    | String(string)\n    | Array(List&lt;JsonValue&gt;)\n    | Object(List&lt;(string, JsonValue)&gt;)\n</code></pre> <p>This type is recursive, but it differs from a simple type like <code>nat</code> in an important way: <code>JsonValue</code> does not appear immediately under a constructor. Instead, it is wrapped inside other data structures (e.g., <code>List</code> in the <code>Array</code> constructor, or <code>List&lt;(string, JsonValue)&gt;</code> in the <code>Object</code> constructor).</p> <p>Suppose we want to implement a function that encodes JSON values as strings \u2014 that is, a recursive function of type <code>JsonValue -&gt; string</code>:</p> <pre><code>  fun json_encode(json_value) : string =\n    fold(json_value) {\n      // ... other constructors are straightforward\n      | Array(json_values) =&gt; ?\n      | Object(key_value_pairs&gt;) =&gt; ?\n    }\n</code></pre> <p>We might try to handle the <code>Array</code> case by matching on the list constructor:</p> <pre><code>      | Array(@head :: tail) =&gt; ?\n</code></pre> <p>The <code>@head</code> pattern works as expected: it binds head to the result of recursively folding over that element. However, the rest of the list (<code>tail</code>) cannot be processed using an <code>@</code>-pattern in the same way. Its type is <code>List&lt;JsonValue&gt;</code>, not <code>JsonValue</code>. Fold-patterns expect a value of the same type as the one being folded over.</p>"},{"location":"language-manual/#top-level-folds","title":"Top-level folds","text":"<p>A top-level <code>fold</code>, unlike the expression-level syntax, has a name, which makes it callable from other folds, and from ordinary functions. This allows us to define separate folds for the three different cases: </p> <pre><code>  fold encode_json_value : JsonValue -&gt; string \n  fold encode_json_array : List&lt;JsonValue&gt; -&gt; List&lt;string&gt; \n  fold encode_json_object : List&lt;(string, JsonValue)&gt; -&gt; List&lt;string&gt; \n</code></pre> <p>From one fold, we can invoke another. But folding is only possible from within a pattern, using the following syntax:</p> <pre><code>    | JsonArray(encode_json_array(@values)) =&gt; ...\n</code></pre> <p>The <code>@</code>-pattern works in the same way here as in expression-level folds, binding values to the result of recursively folding over the list.</p> <p>The following is a complete implementation the JSON encoder using this approach:</p> <pre><code>module Json {\n\n  import String(intercalate)\n\n  type JsonValue\n    = JsonNull\n    | JsonBool(bool)\n    | JsonNumber(double)\n    | JsonString(string)\n    | JsonArray(List&lt;JsonValue&gt;)\n    | JsonObject(List&lt;(string, JsonValue)&gt;)\n\n  fold encode_json_value : JsonValue -&gt; string {\n    | JsonNull =&gt; \n        \"null\"\n    | JsonBool(false) =&gt; \n        \"false\"\n    | JsonBool(true) =&gt; \n        \"true\"\n    | JsonNumber(d) =&gt; \n        double_to_string(d)\n    | JsonString(str) =&gt; \n        \"\\\"\" +++ str +++ \"\\\"\"\n    | JsonArray(encode_json_array(@values)) =&gt; \n        \"[\" +++ intercalate(\",\", values) +++ \"]\"\n    | JsonObject(encode_json_object(@key_value_pairs)) =&gt; \n        \"{\" +++ intercalate(\",\", key_value_pairs) +++ \"}\"\n  }\n\n  fold encode_json_array : List&lt;JsonValue&gt; -&gt; List&lt;string&gt; {\n    | [] =&gt; []\n    | encode_json_value(@value) :: encode_json_array(@values) =&gt; \n        value :: values\n  }\n\n  fold encode_json_object : List&lt;(string, JsonValue)&gt; -&gt; List&lt;string&gt; {\n    | [] =&gt; []\n    | (key, encode_json_value(@value)) :: encode_json_object(@pairs) =&gt; \n        let label = \"\\\"\" +++ key +++ \"\\\"\" \n        in (label +++ \":\" +++ value) :: pairs\n  } \n\n  fun encode_json(value : JsonValue) = encode_json_value(value)\n\n}\n</code></pre>"},{"location":"language-manual/#codata-and-unfold","title":"Codata and unfold","text":"<p>Recursion over ordinary data in Coal (or any language with well-founded recursion) is always guaranteed to terminate. This implies that all data is finite as well. In many cases, this is desirable \u2014 it makes reasoning about programs predictable and safe. However, there are situations where we want potentially infinite structures or non-terminating behavior. For example:</p> <ul> <li>Infinite sequences of numbers, like the natural numbers, are easy to define in Haskell using laziness:</li> </ul> <pre><code>nats = [0..]\n</code></pre> <ul> <li>Programs that continuously run in the background, such as web servers or event loops, inherently involve non-terminating processes.</li> </ul> <p>In Coal, ordinary data cannot be infinite: a <code>List</code>, <code>Tree</code>, or any recursive data type must eventually reach a base case. To express potentially infinite or ongoing computations, Coal provides a separate mechanism called codata.</p>"},{"location":"language-manual/#data-on-demand","title":"Data on demand","text":"<p>The key difference between data and codata lies in how values are produced and consumed. Whereas data is finite and constructed, codata is potentially infinite and observed: you unfold it step by step. The following table gives a comparison between the two:</p> Access pattern Structure Evaluation strategy Invariant Data Recursion (<code>fold</code>) Always finite Eager (strict) Progress Codata Corecursion (<code>unfold</code>) Potentially infinite Lazy (non-strict) Productivity <p>Codata is ideal for representing streams, event sequences, or any ongoing process, where you only need to observe a finite part at a time. </p> <p>A codata type is introduced using the <code>cotype</code> keyword and (like a record type) is defined by a set of comma-separated fields enclosed in curly braces:</p> <pre><code>cotype &lt;Name&gt; = { &lt;Field_1&gt; : &lt;t_1&gt;, ..., &lt;Field_n&gt; : &lt;t_n&gt; }\n</code></pre> <p>Unlike records, the codata field labels start with an uppercase letter.</p>"},{"location":"language-manual/#a-basic-counter","title":"A basic counter","text":"<p>A simple codata type is a counter, which represents an infinite sequence of integers:</p> <pre><code>cotype Counter = { Current : int32, Next : Counter }\n</code></pre> <p>This definition involves two codata fields: <code>Current</code> gives access to the current value, and <code>Next</code> produces the next rendition of the counter. The corecursive counterpart of <code>fold</code> is <code>unfold</code>. To define a counter based on the <code>Counter</code> codata type, we can write:</p> <pre><code>  unfold count_from(n : int32) : Counter {\n    , Current = n\n    , @Next = n + 1\n  }\n</code></pre> <p>Here, the <code>@</code> symbol resurfaces, but this time in the name of the field. In this context, <code>@Next</code> means that the value for <code>Next</code> is obtained corecursively, by invoking <code>count_from</code> again with the field value (in this case, <code>n + 1</code>). Conceptually, the result is equivalent to writing the following, if explicit recursion were possible:</p> <pre><code>  unfold count_from(n : int32) : Counter {\n    , Current = n\n    , Next = count_from(n + 1)\n  }\n</code></pre> <p>We can now observe the counter, by accessing its fields:</p> <pre><code>let counter = count_from(10)\n\ncounter.Current             // =&gt; 10\ncounter.Next.Current        // =&gt; 11\ncounter.Next.Next.Current   // =&gt; 12\n</code></pre> <p>Each observation reveals one additional layer of the codata structure, producing a value that can itself be further observed. Unlike ordinary data, this can continue indefinitely \u2014 you can keep asking for <code>Next</code> without ever reaching a base case.</p> <p>It is also possible to define operations that transform counters while preserving their infinite, coinductive structure:</p> <pre><code>  unfold transform_counter(f : int32 -&gt; int32, c : Counter) : Counter {\n    , Current = f(c.Current)\n    , @Next = (f, c.Next)\n  }\n</code></pre>"},{"location":"license/","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p> <pre><code>MIT License\n\nCopyright (c) 2020\u2013present Heikki Johannes Hild\u00e9n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"}]}